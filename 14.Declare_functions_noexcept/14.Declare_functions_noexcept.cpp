//예외를 방출하지 않을 함수는 noexcept로 선언하라

//c++11에서 함수 선언시 그 함수가 예외를방출하지 않을것임을명시할 때 noexcept라는 키워드를 사용한다.

//noexcept를 사용하는 것은 인터페이스 명세가 명확하며, 함수의 호출자는 함수의 noexcept여부를 통해 코드의 예외 안전성, 효율성에 영향을 미친다.
int f(int x) throw(); //c++98방식
int f(int x) noexcept; //c++11방식

//c++98의 경우 예외 명세가 위반되면 호출 스택이 f를 호출한 지점에 도달할 때까지 풀린다.
//c++11의 경우프로그램 실행이 종료되기 전에 호출 스택이풀릴수도 있고 풀리지 않을 수도 있다.

//호출 스택이 풀리는 것과 풀릴 수도 있는 차이는 컴파일러의 코드 작성에 큰 영향을 끼친다.
//1.noexcept 함수에서 컴파일러의 최적화기는 예외가 함수 바깥으로 전파될 수 있다고 해도 실행시점 스택을 풀기 가능 상태로 유지할 필요없다.
//2.예외가 noexcept 함수를 벗어난다고 해도 noexcept 함수 안의 객체들을 반드시 생성의 반대 순서로 파괴해야 하는 석도 아니다.
//예외 명세가 throw()인 함수의 경우 최적화 유연성이 없으며, 예외 명세가 아예 없는 함수 역시 마찬가지이다.


//반환형식 함수이름(매개변수 목록) noexcept; //최적화 여지가 가장 크다
//반환형식 함수이름(매개변수 목록) throw(); //최적화 여지가 적다.
//반환형식 함수이름(매개변수 목록); //최적화 여지가 적다.

//더욱 강력한 사용 이유가 있는 함수 : 이동 연산들
//예를들어 std::vector에 새 요소를 추가할 경우, 충분한 공간이 부족할 경우 std::vector은 더 큰 메모리 공간을 할당하고 사용한다.
//c++98에서는 기존 메모리에서 새 메모리로 일일이 복사후 기존 메모리에 객체를 파괴하여 강력한 예외 안전성을 복사하였다.

//c++11에서는 std::vector 요소들의 복사를 이동으로 대체함으로써 요소 옮기기를 최적화하는 것이 자연스러운 방식이다.
//하지만 push_back의 예외 안전성 보장이 위반될 수 있다.
//이러한 문제 때문에 c++11컴파일러는 예외 방출이 확실하지 않을 경우에는 복사 연산들을 이동연산으로 변경하지 않는다.

//std::vector::push_back, 표준 라이브러리의 여러 함수는 "가능하면 이동하되 필요하면 복사한다" 전략을 활용한다.
//(std::vector::reserve, std::deque::insert 등) 이러한 함수들은 예외를 방출하지 않음이 알려진 경우에만 복사 연산에서 이동 연산으로 대체한다.
//이러한 예외를 방출하지 않는 기준은 주어진 연산이 noexcept로 선언되어 있는지 확인한다.

//유사한 예) swap, swap는 noexcept여부를 사용자 정의 swap들의 noexcept 여부에 의존한다.
template< class T, size_t N >
void swap(T(&a)[N], T(&b)[N]) noexcept (noexcept (swap(*a, *b)));

template< class T1, class T2 >
struct pair {
	//...
		void swap(pair& p) noexcept(noexcept(swap(first, p.first)) && noexcept(swap(second, p.second)));
};

//이 함수들은 조건부 noexcept이다.즉, noexcept인지의 여부는 noexcept 절 안의 표현식들의 noexcept 인지에 의존한다.
//noexcept인지의 여부에 따라 swap함수를 작성할 때에는 가능한 한 항상 noexcept를 지정하는 것이 바람직하다.

//noexcept는 함수의 인터페이스의 일부이다.
//따라서 함수의 구현이 예외를 방출하지 않는다는 성질을 오랫동안 유지할 결심이 선 경우에만 함수를 noexcept로 선언해야 한다.

//대부분의 함수는 예외에 중립적(exception - neutral)이다.예외에 중립적인 함수는 스스로 예외를 던지지 않지만, 
//예외를 던지는 다른 함수들을 호출할 수는 있다.때문에 예외 중립적인 함수는 결코 noexcept가 될 수 없다.

//메모리 해제 함수들(delete, delete[]), 소멸자 : 암묵적 noexcept

//넓은 계약을 가진 함수는 전제조건이 없는 함수를 말한다.프로그램 상태와는 무관하게 호출한다.
//넓은 계약 함수는 결코 미정의 행동을 보이지 않는다.그 외의 함수는 전부 좁은 계약 함수인데 이는 전제조건이 위반되면 그 결과는 미정의 행동이다.
//좁은 계약 함수에 noexcept - 예외를 던지면 프로그램종료...
//그 결과 라이브러리 설계자들은 넓은 계약을 가진 함수들에 대해서만 noexcept를 선호.

void setup() {};
void cleanup() {};
void doWork() noexcept
{
	setup();
	cleanup();
}
//이처럼 noexcept함수가 적법한 이유는 noexcept 보장이 없는 코드에 의존하는 경우가 있으므로, 
//c++은 이런 코드를 허용하며, 일반적으로 컴파일러는 이에 대해 경고 메시지를 표시하지 않는다.

/*
- noexcept는 함수의 인터페이스의 일부이다.이는 호출자가 noexcept 여부에 의존할 수 있음을 뜻한다.
- noexcept 함수는 비noexcept함수보다 최적화의 여지가 크다.
- noexcept는 이동 연산들과 swap, 메모리 해제함수들, 그리고 소멸자들에 특히나 유용하다.
- 대부분의 함수는 noexcept가 아니라 예외에 중립적이다.
*/

int main()
{
	return 0;
}