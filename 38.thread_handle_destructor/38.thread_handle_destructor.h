#pragma once
//스레드 핸들 소멸자들의 다양한 행동 방식을 주의하라.

//std::thread와 비지연 과제에 대한 미래 객체는 시스템 스레드에 대응된다는 점에서 모두 '시스템 스레드 핸들' 이라고 말할 수 있다.
//이러한 스레드 핸들의 소멸자에 행동 방식에 대해 다루는 것이 이 항목이다.
//일단 std::thread의 소멸자에 대한 부분은 항목 37에서 다루고 있다.그러므로 이 항목에서는 미래 객체 소멸자의 행동 방식들에 대해 다룬다.
// 미래객체 소멸자 : 어떨때에는 암묵적 join, 어떨때는 암묵적 detach

//[Caller] 미래객체<--------  std::promis [Callee]

//[Caller] 미래객체<-------- 공유 상태(피호출자의 결과) <-------- std::promis [Callee]

//행동 방식은 제각각인 것처럼 보일 수 있지만, 사실 핵심은 간단하다.
//"시스템 스레드과 대응되는 유일한 미래객체일 경우에만, 시스템 스레드에 대해 암묵적 join을 수행한다. 그 외의 경우에는 그냥 바로 객체가 소멸된다."
//즉, 어떤 미래 객체가 소멸자에서 암묵적 join을 수행할 지, 아니면 그냥 바로 객체가 소멸되고 끝날 지 
//판단하는 것은 이 미래 객체가 시스템 스레드와 대응되는 유일한 미래 객체인지만 생각해보면 된다.

//1. 지연된 과제에 대한 미래 객체
//- 대응되는 시스템 스레드가 없으므로 바로 객체가 소멸된다.
//2. std::async(with std::launch::async) 호출에 의해 생성된 공유 상태를 참조하는 std::future
//- 비동기적으로 실행된 과제의 공유 상태에 유일하게 대응되는 미래 객체이므로 암묵적 join이 수행된 뒤 객체가 소멸된다.
//3. std::async(with std::launch::async) 호출에 의해 생성된 공유 상태를 참조하는 std::shared_future
//- 여러 개의 std::shared_future가 공유 상태를 참조하고 있을 것이다.
//- 따라서 공유 상태를 참조하고 있는 마지막 std::shared_future 만 암묵적 join이 수행된다.
//- 마지막이 아닌 std::shared_future는 암묵적 detach를 수행하는 것과 비슷하다.
//4. std::packaged_task가 std::thread에 의해 실행되고 있을 때, std::packaged_task으로 부터 얻어진 std::future
//- 시스템 스레드가 std::thread에 대응되므로, std::future는 시스템 스레드에 대한 책임이 없다.따라서 바로 객체가 소멸된다.

//즉, 결과적으로만 보면 "std::async를 통해서 시동된 비지연(지연되지 않은) 과제에 대한 공유 상태를 
//참조하는 마지막 미래 객체의 소멸자"의 경우에만 과제가 완료될 때까지 차단(즉, 암묵적 join) 되는 것이다.
//그리고 더 나아가면 사실 std::thread 소멸자의 행동 방식과도 일맥상통하는 원리를 얻을 수 있다.
//결국에는 시스템 스레드(바탕 스레드)에 대응되는 마지막 핸들이 시스템 스레드를 책임져야하는 것인데, 
//시스템 스레드가 종료되기 전에 핸들(객체)가 소멸될 경우, 바로 객체가 소멸되지 않고 특별한 행동이 일어나는 것이다.
//그리고 그 특별한 행동은 std::thread의 경우에는 프로그램 종료, 미래 객체의 경우에는 암묵적 join인 것이다.
//다만, 표준위원회가 왜 std::thread와 미래 객체에 대해 특별한 행동으로서 서로 다른 것을 선택했는지는 의문??

//std::thread는 항상 unjoinable한 상태에서만 소멸할 수 있도록 코드를 짜고, 
//미래 객체가 소멸하면서 암시적 join이 일어날 수 있는 곳에는 주석으로서 그 사실을 명시한다.

//- 미래 객체의 소멸자는 그냥 미래 객체의 자료 멤버들을 파괴할 뿐이다.
//- std::async를 통해 시동된 비지연 과제에 대한 공유 상태를 참조하는 마지막 미래 객체의 소멸자는 그 과제가 완료될 때까지 차단된다.
