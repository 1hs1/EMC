// 이동연산이 존재하지 않고, 저렴하지 않고, 적용되지 않는다고 가정하라

// 이동 의미론을 지원하지 않는 형식들이 많다
// C++11에서는 이동을 복사보다 빠르게 구현할 수 있는 형식들에는 이동연산을 추가
// 사용자 응용 프로그램에 있는 형식들이 C++11에 맞게 완전히 수정되지 않았다면, 컴파일러가
// 이동을 지원한다고 해도 응용 프로그램의 성능이 저절로 높아지지는 않는다.
// 이동연산을 명시적으로 지원하지 않는 형식에 대해 C++11이 자동으로 이동 연산들을 작성해 주긴 하지만,
// 형식에 복사연산, 이동연산, 소멸자가 하나라도 있으면 자동 작성은 일어나지 않는다.(항목17)
// 형식의 자료 멤버나 기반 클래스에 이동이 비활성화 되어 있으면 이동 연산 작성은 일어나지 않는다. (항목11)

// 컨테이너에 담긴 내용을 정말로 저렴하게 이동하는 방법이 없는 컨테이너들도 있고,
// 컨테이너가 제공하는 진정으로 저렴한 이동 연산이 요구하는 까다로운 조건을 컨테이너 요소들이 만족할 수 없는 경우
// 이동을 명시적으로 지원하는 형식에서도 성능상의 이득이 크지 않을 수 있다.
// 대표적인 예1 : std::array
// 다른 컨테이너들은 컨테이너 내용이 저장된 힙 메모리를 가리키는 포인터만 담는다.(상수시간 이동)
// std::array의 내용은 std::array객체 자체에 직접 저장 (선형시간 이동)
// 대표적인 예2 : std::string
// 상수시간 이동과 선형시간 복사를 제공,
// 문자열 구현중 작은 문자열 최적화를 사용.(SSO)
// 작은 물자열(용량이 15자 이하인)을 std::string 객체 안의 버퍼에 저장하고, 힙에 할당한 저장소는 사용하지 않음
// 이런 SSO를 사용하는 작은 문자열의 이동은 복사보다 빠르지 않다.

// 빠른 이동 연산을 지원하는 형식에서도, 컽으로 보기에 이동이 일어날 만한 상황에서 사실은 복사가 일어난다(항목14)
// 이동 연산들이 예외를 던지지 않음이 확실한 경우에만 바탕 복사 연산들을 이동 연산들로 대체한다.
// 해당 이동 연산이 noexcept로 선언되어 있지 않으면 컴파일러는 여전히 복사 연산을 호출할 수 있다.

// 오직 오른값만 이동 연산의 원본이 될 수 있다.(항목25)
// 원본 객체가 왼값이면 이동 의미론이 효율성에 이득이 되지 않는다.

// 템플릿을 작성할 때에는 대체로 이동 연산들이 존재하지 않고, 저렴하지 않고, 적용되지 않는다고 가정하라
// 모든 형식을 알 수 없기 때문이다.
// 이동 의미론이 존재하기 전인 C++98시절에서처럼 객체의 복사를 보수적으로 다루어야 한다.
// 이점은 안정적이지 않은 코드, 즉 코드가 사용하는 형식의 특징들이 비교적 자주 바뀌는 코드에도 적용된다.

// 코드가 사용하는 구체적인 형식들을 이미 알 수 있는, 형식들의 특징(저렴한 이동연산을 지원하는지의 여부)이 
// 바뀌지 않으리라 확신하는 경우, 이번항목의 가정을 둘 필요가 없다.

// 1. 이동 연산들이 존재하지 않고, 저렴하지 않고, 적용되지 않을 것이라고 가정하라.
// 2. 형식들과 이동 의미론 지원 여부를 미리 알 수 있는 경우에는 그런 가정을 둘 필요가 없다.
int main(){}