// 특수 멤버 함수들의 자동 작성 조건을 숙지하라
// 특수 멤버 함수 : 스스로 기꺼이 작성하는 멤버함수
// C++98 특수멤버함수 : 기본생성자, 소멸자, 복사생성자, 복사배정연산자
// 이 함수들이 클래스에 명시적으로 선언되어 있지 않아도, 이 함수들을 사용하는 코드가 존재할 때에만 작성된다.

// 기본 생성자 : 클래스에 생성자가 하나도 선언되어 있지 않을 때 작성
// (인수들을 받는 생성자가 명시적으로 선언되었으면, 기본생성자가 작성되지 않음)
// 작성된 특수 멤버 함수들은 암묵적으로 public, inline, 비가상이다.
// 가상소멸자가 있는 기반 클래스를 상속하는 경우 파생 클래스의 소멸자는 가상으로 선언한다.

// C++11에 추가된 특수멤버함수 : 이동생성자, 이동배정연산자
class Widget {
public:
	Widget(Widget&& rhs);				// 이동생성자 : 주어진 매개변수 rhs의 비정적 자료 멤버 각각을 이용해서 클래스의 해당 자료 멤버들을 각각 이동 생성(기반클래스 포함)
	Widget& operator=(Widget&& rhs);	// 이동배정연산자 : 주어진 매개변수 rhs의 비정적 자료 멤버 각각을 클래스의 해당 자료 멤버들에 각각 이동 배정(기반클래스 포함)
};
// 이동 연산이 실제로 일어난다는 보장은 없음. 멤버별 이동은 멤버별 이동 요청에 더 가깝다.
// 이동이 활성화되지 않은 형식(C++98 클래스)은 그 형식이 제공하는 복사 연산들을 통해 이동됨.
// 각각의 멤버별 이동의 핵심은 이동할 객체에 std::move를 적용, 그 적용 결과는 함수 중복적재 해소 과정에서 이동과 복사 중 어떤것을 수행해야 할지를 결정(항목23)

// 두 복사 연산은 서로 독립적.
// 복사 생성자를 선언하고 복사 배정 연산자를 선언하지 않고, 복사 배정연산이 필요한 코드가 있다면, 복사 배정 연산자가 자동으로 작성됨
// 복사 생성자를 선언하지 않고, 복사 배정 연산자를 선언하고, 복사 생성이 필요한 코드가 있다면, 복사 생성자가 자동으로 작성됨

// 두 이동 연산은 독립적이지 않음
// 이동 생성자가 선언되어 있으면 이동배정연산자를 작성하지 못하게 함.
// 이동 배정연산자가 선언되어 있으면 이동 생성자를 작성하지 못하게 함.

// 복사 연산을 하나라도 명시적으로 선언한 클래스에 대해서 이동 연산들이 작성되지 않음.
// 이동 연산을 하나라도 명시적으로 선언한 클래스에 대해서 복사 연산들이 작성되지 않음

// 3의 규칙 : 복사 생성자와 복사 배정 연산자, 소멸자 중 하나라도 선언했다면, 나머지 둘도 선언해야 한다.
// 사용자 선언 소멸자가 있는 클래스에 대해서는 이동 연산들을 작성하지 않는다.

// c++11에서는 기본 행동을 사용하겠다는 의사를 '=default'를 이용해서 명시적으로 표현
class Widget11 {
public:
	~Widget11();	// 사용자 선언 소멸자

	Widget11(const Widget11&) = default;	// 기본 복사 생성자. 기본 행동 OK
	Widget11& operator = (const Widget11&) = default;	// 기본 복사 배정. 기본 행동 OK
};

// 소멸자를 직접 선언하면 이동 연산들의 자동 작성이 금지된다. 이동 능력을 지원하고 싶다면, 이동연산들에 "=default"를 지정(복사도 마찬가지)
class Base {
public:
	virtual ~Base() = default;	// 소멸자를 가상으로 선언

	Base(Base&&) = default;		// 이동 지원
	Base& operator=(Base&&) = default;

	Base(const Base&) = default;	// 복사 지원
	Base& operator=(Base&) = default;
};

// 멤버 함수 템플릿이 존재하면 특수 멤버 함수의 자동 작성이 비활성화된다는 규칙은 없다.
class WidgetT {
	template<typename T>
	WidgetT(const T& rhs);	// 그 어떤것으로도 Widget을 생성

	template<typename T>
	WidgetT& operator=(const T& rhs);	// 그 어떤것으로도 Widget을 배정
};
// WidgetT의 복사 연산들과 이동 연산들을 작성한다.(항목 26)

int main(){}

// 1. 컴파일러가 스스로 작성할 수 있는 멤버 함수들, 즉 기본 생성자와 소멸자, 복사 연산들, 이동 연산들을 가리켜 특수 멤버 함수라고 부른다.
// 2. 이동 연산들은 이동 연산들이나 복사 연산들, 소멸자가 명시적으로 선언되어 있지 않은 클래스에 대해서만 자동으로 작성된다.
// 3. 복사 생성자는 복사 생성자가 명시적으로 선언되어 있지 않은 클래스에 대해서만 자동으로 작성되며, 만일 이동 연산이 하나라도 선언되어 있으면
// 삭제된다. 복사 배정 연산자는 복사 배정 연산자가 명시적으로 선언되어 있지 않은 클래스에 대해서만 자동으로 작성되며, 만일 이동 연산이 하나라도 선언되어 
// 있으면 삭제된다. 소멸자가 명시적으로 선언되 클래스에서 복사 연산들이 자동 작성되는 기능은 비권장이다.
// 4. 멤버 함수 템플릿 때문에 특수 멤버 함수의 자동 작성이 금지되는 경우는 전혀 없다.
